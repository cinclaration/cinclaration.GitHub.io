<style>
  /* Menu Styling */
  #menu {
    position: absolute;
    top: 20px;
    left: 20px;
    width: 200px;
    padding: 10px;
    background: rgba(255, 255, 255, 0.9);
    border-radius: 10px;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    z-index: 10;
    cursor: grab;
  }

  #menu h3 {
    margin: 0 0 10px;
    font-size: 18px;
    color: #333;
    text-align: center;
  }

  #menu button {
    width: 100%;
    padding: 10px;
    margin: 5px 0;
    font-size: 14px;
    background: #007bff;
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    transition: background 0.3s;
  }

  #menu button:hover {
    background: #0056b3;
  }
</style>

<div id="menu">
  <h3>Simulation Menu</h3>
  <button id="resetBtn">Reset Simulation</button>
  <button id="toggleGravityBtn">Toggle Gravity</button>
  <button id="spawnParticlesBtn">Spawn Particles</button>
</div>





<script>
  // Menu Dragging Logic
  const menu = document.getElementById("menu");
  let isDragging = false;
  let offsetX, offsetY;

  menu.addEventListener("mousedown", (e) => {
    isDragging = true;
    offsetX = e.clientX - menu.offsetLeft;
    offsetY = e.clientY - menu.offsetTop;
    menu.style.cursor = "grabbing";
  });

  document.addEventListener("mousemove", (e) => {
    if (isDragging) {
      menu.style.left = `${e.clientX - offsetX}px`;
      menu.style.top = `${e.clientY - offsetY}px`;
    }
  });

  document.addEventListener("mouseup", () => {
    isDragging = false;
    menu.style.cursor = "grab";
  });

  // Menu Buttons Logic
  document.getElementById("resetBtn").addEventListener("click", resetSimulation);
  document.getElementById("toggleGravityBtn").addEventListener("click", toggleGravity);
  document.getElementById("spawnParticlesBtn").addEventListener("click", spawnParticles);
</script>




<script>
  const particles = [];
  let gravityEnabled = false;

  // Create Particles on Touch
  function createParticle(x, y) {
    particles.push({
      x,
      y,
      vx: (Math.random() - 0.5) * 4,
      vy: (Math.random() - 0.5) * 4,
      size: Math.random() * 5 + 5,
      color: `hsla(${Math.random() * 360}, 70%, 70%, 1)`,
      alpha: 1,
    });
  }

  // Draw Particles
  function drawParticles() {
    particles.forEach((particle, index) => {
      ctx.beginPath();
      ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
      ctx.fillStyle = particle.color.replace(/[\d.]+\)$/g, `${particle.alpha})`);
      ctx.fill();
      ctx.closePath();

      // Update Particle Position
      particle.x += particle.vx;
      particle.y += particle.vy;

      // Apply Gravity if Enabled
      if (gravityEnabled) particle.vy += 0.1;

      // Fade Out and Remove Particle
      particle.alpha -= 0.01;
      if (particle.alpha <= 0) particles.splice(index, 1);
    });
  }
</script>





<script>
  // Physics: Collision Detection
  function handleParticleCollisions() {
    for (let i = 0; i < particles.length; i++) {
      for (let j = i + 1; j < particles.length; j++) {
        const p1 = particles[i];
        const p2 = particles[j];
        const dx = p1.x - p2.x;
        const dy = p1.y - p2.y;
        const distance = Math.sqrt(dx * dx + dy * dy);

        if (distance < p1.size + p2.size) {
          // Bounce Particles
          const angle = Math.atan2(dy, dx);
          const speed1 = Math.sqrt(p1.vx * p1.vx + p1.vy * p1.vy);
          const speed2 = Math.sqrt(p2.vx * p2.vx + p2.vy * p2.vy);

          p1.vx = speed2 * Math.cos(angle);
          p1.vy = speed2 * Math.sin(angle);
          p2.vx = speed1 * Math.cos(angle + Math.PI);
          p2.vy = speed1 * Math.sin(angle + Math.PI);

          // Chemistry: Change Color on Collision
          p1.color = `hsla(${Math.random() * 360}, 70%, 70%, 1)`;
          p2.color = `hsla(${Math.random() * 360}, 70%, 70%, 1)`;
        }
      }
    }
  }

  // Reset Simulation
  function resetSimulation() {
    particles.length = 0; // Clear all particles
  }

  // Toggle Gravity
  function toggleGravity() {
    gravityEnabled = !gravityEnabled;
  }

  // Spawn Random Particles
  function spawnParticles() {
    for (let i = 0; i < 20; i++) {
      createParticle(Math.random() * canvas.width, Math.random() * canvas.height);
    }
  }
</script>



<script>
  // Main Animation Loop
  function animate() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    drawParticles(); // Draw particles
    handleParticleCollisions(); // Handle physics interactions

    requestAnimationFrame(animate);
  }

  // Event Listeners for Touch and Mouse
  canvas.addEventListener("mousedown", (e) => {
    createParticle(e.clientX, e.clientY);
  });

  canvas.addEventListener("touchstart", (e) => {
    const touch = e.touches[0];
    createParticle(touch.clientX, touch.clientY);
  });

  canvas.addEventListener("mousemove", (e) => {
    if (e.buttons === 1) createParticle(e.clientX, e.clientY);
  });

  canvas.addEventListener("touchmove", (e) => {
    const touch = e.touches[0];
    createParticle(touch.clientX, touch.clientY);
  });

  // Start the Simulation
  animate();
</script>






<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Eclipse Flow</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: black;
      font-family: Arial, sans-serif;
    }

    canvas {
      display: block;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>
  <script>
    // Canvas and Context
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    // Resize Canvas on Window Resize
    window.addEventListener('resize', () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    });

    const waves = []; // Array to store wave patterns
    const ripples = []; // Array to store drag-based ripple effects

    // Generate HD Waves
    function generateHDWaves() {
      for (let i = 0; i < 5; i++) {
        waves.push({
          y: Math.random() * canvas.height, // Vertical position
          amplitude: Math.random() * 50 + 50, // Wave height
          frequency: Math.random() * 0.02 + 0.01, // Wave speed
          phase: Math.random() * Math.PI * 2, // Wave phase
          color: `hsla(${Math.random() * 360}, 70%, 70%, 0.7)`,
          speed: Math.random() * 0.03 + 0.01, // Speed of phase shift
        });
      }
    }

    // Draw HD Waves
    function drawHDWaves() {
      waves.forEach(wave => {
        ctx.beginPath();
        for (let x = 0; x < canvas.width; x += 1) {
          const y =
            wave.y +
            wave.amplitude *
              Math.sin(wave.frequency * x + wave.phase); // Wave formula
          ctx.lineTo(x, y);
        }
        ctx.strokeStyle = wave.color;
        ctx.lineWidth = 3; // Make the waves bold for HD effect
        ctx.shadowBlur = 10; // Add a glow effect
        ctx.shadowColor = wave.color;
        ctx.stroke();
        ctx.closePath();

        // Animate wave phase
        wave.phase += wave.speed;
      });
    }

    let isDragging = false;

    // Start Drag
    canvas.addEventListener('mousedown', (e) => {
      isDragging = true;
      createRipple(e.clientX, e.clientY);
    });

    canvas.addEventListener('touchstart', (e) => {
      isDragging = true;
      const touch = e.touches[0];
      createRipple(touch.clientX, touch.clientY);
    });

    // Dragging
    canvas.addEventListener('mousemove', (e) => {
      if (isDragging) {
        createRipple(e.clientX, e.clientY);
      }
    });

    canvas.addEventListener('touchmove', (e) => {
      if (isDragging) {
        const touch = e.touches[0];
        createRipple(touch.clientX, touch.clientY);
      }
    });

    // Stop Drag
    canvas.addEventListener('mouseup', () => (isDragging = false));
    canvas.addEventListener('touchend', () => (isDragging = false));

    // Create Ripple
    function createRipple(x, y) {
      ripples.push({
        x,
        y,
        radius: 0,
        maxRadius: 200,
        growthSpeed: 5,
        color: 'rgba(255, 255, 255, 0.5)',
      });
    }

    // Draw Ripples
    function drawRipples() {
      ripples.forEach((ripple, index) => {
        ctx.beginPath();
        ctx.arc(ripple.x, ripple.y, ripple.radius, 0, Math.PI * 2);
        ctx.strokeStyle = ripple.color;
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.closePath();

        // Increase ripple radius
        ripple.radius += ripple.growthSpeed;

        // Remove ripples that exceed their maximum size
        if (ripple.radius > ripple.maxRadius) {
          ripples.splice(index, 1);
        }
      });
    }

    // Ripple-Wave Interaction
    function rippleWaveInteraction() {
      ripples.forEach(ripple => {
        waves.forEach(wave => {
          const dist = Math.abs(ripple.y - wave.y); // Distance between ripple and wave
          if (dist < ripple.radius) {
            // Distort wave properties temporarily
            wave.amplitude += Math.random() * 10 - 5;
            wave.frequency += Math.random() * 0.005 - 0.0025;
          }
        });
      });
    }

    // Main Game Loop
    function animate() {
      // Clear canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Draw and update elements
      drawHDWaves(); // Draw high-definition waves
      drawRipples(); // Draw drag-based ripples
      rippleWaveInteraction(); // Interact ripples with waves

      // Loop the animation
      requestAnimationFrame(animate);
    }

    // Initialize and Start the Game
    generateHDWaves(); // Create the wave patterns
    animate(); // Start the animation loop
  </script>
</body>
</html>